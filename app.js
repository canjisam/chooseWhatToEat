// Removed: const foodCategories = { ... };
// Added below to load the foodCategories JSON dynamically:
let foodCategories = {};
fetch('./foodCategories.json')
	.then(response => response.json())
	.then(data => { foodCategories = data; });

function getRandomFood(list) {
    return list[Math.floor(Math.random() * list.length)];
}

function animateSelection(callback) {
    let count = 0;
    const animation = setInterval(() => {
        callback();
        if (++count > 10) clearInterval(animation);
    }, 100);

    setTimeout(() => {
        generateText();
    },1500);
}

function chooseByCategory() {
    const category = getRandomFood(Object.keys(foodCategories));
    animateSelection(() => {
        document.getElementById('result').textContent = `${category} · ${getRandomFood(foodCategories[category])}`;
    });
}

function chooseAll() {
    const allFoods = Object.entries(foodCategories).flatMap(([category, foods]) =>
        foods.map(food => `${category} · ${food}`)
    );
    animateSelection(() => {
        document.getElementById('result').textContent = getRandomFood(allFoods);
    });
}

document.addEventListener('copy', function(e) {
    const selection = window.getSelection().toString();
    if (selection) {
        const notification = document.getElementById('copy-notification');
        notification.textContent = `内容来自【@canjisam今天吃什么？随机选择器】\n${selection}`;
        notification.style.display = 'block';
        setTimeout(() => {
            notification.style.display = 'none';
        }, 2500);
    }
});
async function generateText() {
    const foodText = document.getElementById('result').textContent;
    const basePrompt = `你只要告诉我提示词是什么，不要返回任何其他内容。你先对${foodText}这个食物进行外貌特征总结，尽可能详细地返回一个可以用于AI生成这个关键词相关的照片风格的英文提示词。`;
    
    const models = ['openai', 'openai-large', 'deepseek-r1', 'deepseek-r1-llama', 'qwen-reasoning', 'gemini-thinking', 'midijourney','hypnosis-tracy'];
    const resultsContainer = document.getElementById('generated-img');
    resultsContainer.style.display = 'grid';
    resultsContainer.style.gridTemplateColumns = 'repeat(auto-fill, minmax(300px, 1fr))';
    resultsContainer.style.gap = '20px';
    resultsContainer.style.padding = '20px';
    resultsContainer.innerHTML = '';
    
    try {
        await Promise.all(models.map(async model => {
            try {
                const response = await fetch(`https://text.pollinations.ai/${encodeURIComponent(basePrompt)}?model=${model}&private=true`);
                const promptText = await response.text();
                
                const modelContainer = document.createElement('div');
                modelContainer.className = 'model-container';
                modelContainer.style.border = '1px solid #ddd';
                modelContainer.style.borderRadius = '8px';
                modelContainer.style.padding = '10px';
                modelContainer.style.backgroundColor = '#f9f9f9';
                modelContainer.innerHTML = `
                    <h3 style="margin-top:0;z-index:999;">${model}</h3>
                    <div class="model-image" id="${model}-image" style="height:300px;display:flex;align-items:center;justify-content:center;"><p>正在生成图片...</p></div>
                    <div style="display:flex;gap:10px;margin-top:10px;">
                        <button class="btn btn-regenerate" onclick="regenerateImage('${model}', '${encodeURIComponent(promptText)}')" style="flex:1;">感觉图片不对</button>
                        <button class="btn btn-save" onclick="saveImage('${model}')" style="flex:1;">保存图片</button>
                    </div>
                `;
                resultsContainer.appendChild(modelContainer);
                await generateImageForModel(model, promptText);
            } catch (error) {
                console.error(`Error processing model ${model}:`, error);
                document.getElementById(`${model}-image`).innerHTML = '<p>生成失败，请重试</p>';
            }
        }));
    } catch (error) {
        console.error('Error generating text:', error);
        document.getElementById('generatedText').innerHTML = '<p>生成提示词失败，请重试</p>';
    }
}

async function generateImageForModel(model, prompt) {
    try {
        const params = new URLSearchParams({
            model: 'flux',
            width: '512',
            height: '512',
            private: 'true'
        });
        
        const apiUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(prompt)}?${params.toString()}`;
        const response = await fetch(apiUrl);
        const imageUrl = response.url;
        
        document.getElementById(`${model}-image`).innerHTML = `<img src="${imageUrl}" alt="Generated by ${model}">`;
    } catch (error) {
        console.error(`Error generating image for ${model}:`, error);
        document.getElementById(`${model}-image`).innerHTML = '<p>生成图片失败</p>';
    }
}

function regenerateImage(model, prompt) {
    document.getElementById(`${model}-image`).innerHTML = '<p>正在重新生成图片...</p>';
    generateImageForModel(model, decodeURIComponent(prompt));
}

async function saveImage(model) {
    try {
        const img = document.querySelector(`#${model}-image img`);
        if (!img) {
            throw new Error('No image found');
        }

        // 创建一个临时的a标签用于下载
        const link = document.createElement('a');
        const foodName = document.getElementById('result').textContent.replace(/[\/\\:*?"<>|]/g, '_');
        link.download = `食物图片_${foodName}_${model}_${new Date().getTime()}.png`;
        
        // 使用fetch获取图片并转换为blob
        const response = await fetch(img.src);
        const blob = await response.blob();
        link.href = URL.createObjectURL(blob);
        
        // 触发下载
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);

        // 显示下载成功通知
        const notification = document.getElementById('copy-notification');
        notification.textContent = '图片保存成功！';
        notification.style.display = 'block';
        setTimeout(() => {
            notification.style.display = 'none';
        }, 2500);
    } catch (error) {
        console.error('Error saving image:', error);
        alert('保存图片失败，请重试');
    }
}


async function testAllModels() {
    const models = await fetch('./model.json').then(res => res.json());
    const resultsContainer = document.getElementById('modelResults');
    
    for (const model of models) {
        const modelCard = document.createElement('div');
        modelCard.className = 'model-card';
        modelCard.innerHTML = `
            <h3>${model.name} (${model.description})</h3>
            <div class="model-content">
                <div class="model-text"></div>
                <div class="model-image"></div>
            </div>
        `;
        resultsContainer.appendChild(modelCard);
        
        await testModel(model, modelCard);
    }
}

async function testModel(model, cardElement) {
    const foodText = '担担面';
    const basePrompt = `你只要告诉我提示词是什么，不要返回任何其他内容。你先对${foodText}这个食物总结外貌特征，尽可能详细地返回一个可以用于AI生成这个关键词相关的图片的英文提示词。`;
    
    try {
        // 文本生成
        const textParams = new URLSearchParams({
            model: model.name,
            private: 'true'
        });
        
        const textApiUrl = `https://text.pollinations.ai/${encodeURIComponent(basePrompt)}?${textParams.toString()}`;
        const textResponse = await fetch(textApiUrl);
        const promptText = await textResponse.text();
        
        cardElement.querySelector('.model-text').innerHTML = `<p>提示词: ${promptText}</p>`;
        
        // 图片生成
        const imageParams = new URLSearchParams({
            model: 'flux',
            width: '512',
            height: '512',
            private: 'true'
        });
        
        const imageApiUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(promptText)}?${imageParams.toString()}`;
        const imageResponse = await fetch(imageApiUrl);
        const imageUrl = imageResponse.url;
        
        cardElement.querySelector('.model-image').innerHTML = `<img src="${imageUrl}" alt="Generated by ${model.name}">`;
    } catch (error) {
        console.error(`Error testing model ${model.name}:`, error);
        cardElement.querySelector('.model-text').innerHTML = '<p>测试失败</p>';
    }
}

// 当测试页面加载时自动运行测试
if (window.location.pathname.includes('model_test.html')) {
    document.addEventListener('DOMContentLoaded', testAllModels);
}